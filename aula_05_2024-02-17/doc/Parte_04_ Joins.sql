USE TUNNING
GO

--ATIVAR O PLANO DE EXECUÇÃO REAL

--EXEMPLO 01

SELECT A.NOME AS ALUNO, A.SEXO AS SEXO_ALUNO, A.DATA_NASCIMENTO
FROM ALUNOS A
INNER JOIN MATRICULAS M ON (M.ID_ALUNO = A.ID)
WHERE A.ID = 1;
GO

SELECT A.NOME AS ALUNO, A.SEXO AS SEXO_ALUNO, A.DATA_NASCIMENTO
FROM ALUNOS A
INNER JOIN MATRICULAS M ON (M.ID_ALUNO = A.ID)
GO

SELECT A.NOME AS ALUNO, A.SEXO AS SEXO_ALUNO, A.DATA_NASCIMENTO, M.DATA_MATRICULA  --posso substituir a data por outro campo e obter um MERGE?
FROM ALUNOS A
INNER JOIN MATRICULAS M ON (M.ID_ALUNO = A.ID)
GO

--POSSO CRIAR UM ÍNDICE EM MATRÍCULAS PARA RESOLVER ISSO? QUAL?




--EXEMPLO 02

SELECT A.NOME AS ALUNO, A.SEXO AS SEXO_ALUNO, R.NOME AS RESPONSAVEL, R.CPF AS CPF_RESPONSAVEL
FROM ALUNOS A
INNER JOIN RESPONSAVEIS R ON (A.ID_RESPONSAVEL = R.ID)
WHERE A.ID = 1;
GO


SELECT A.NOME AS ALUNO, A.SEXO AS SEXO_ALUNO, R.NOME AS RESPONSAVEL, R.CPF AS CPF_RESPONSAVEL
FROM ALUNOS A
INNER JOIN RESPONSAVEIS R ON (A.ID_RESPONSAVEL = R.ID);
GO

--CREATE NONCLUSTERED INDEX IDX_ALUNOS_01 ON ALUNOS(ID_RESPONSAVEL) INCLUDE(NOME, SEXO);
--GO

SELECT A.NOME AS ALUNO, A.SEXO AS SEXO_ALUNO, R.NOME AS RESPONSAVEL, R.CPF AS CPF_RESPONSAVEL
FROM ALUNOS A
INNER JOIN RESPONSAVEIS R ON (A.ID_RESPONSAVEL = R.ID);
GO

--DROP INDEX IDX_ALUNOS_01 ON ALUNOS;

--EXEMPLO 03 (HINTs)

SELECT A.NOME AS ALUNO, A.SEXO AS SEXO_ALUNO, R.NOME AS RESPONSAVEL, R.CPF AS CPF_RESPONSAVEL
FROM ALUNOS A
INNER JOIN RESPONSAVEIS R ON (A.ID_RESPONSAVEL = R.ID);
GO

SELECT A.NOME AS ALUNO, A.SEXO AS SEXO_ALUNO, R.NOME AS RESPONSAVEL, R.CPF AS CPF_RESPONSAVEL
FROM ALUNOS A
INNER LOOP JOIN RESPONSAVEIS R ON (A.ID_RESPONSAVEL = R.ID);
GO

SELECT A.NOME AS ALUNO, A.SEXO AS SEXO_ALUNO, R.NOME AS RESPONSAVEL, R.CPF AS CPF_RESPONSAVEL
FROM ALUNOS A
INNER MERGE JOIN RESPONSAVEIS R ON (A.ID_RESPONSAVEL = R.ID);
GO

/*
SELECT A.NOME AS ALUNO, A.SEXO AS SEXO_ALUNO, R.NOME AS RESPONSAVEL, R.CPF AS CPF_RESPONSAVEL
FROM ALUNOS A
INNER JOIN RESPONSAVEIS R ON (A.ID_RESPONSAVEL = R.ID)
WHERE A.ID = 1;
GO
*/


SELECT A.NOME AS ALUNO, A.SEXO AS SEXO_ALUNO, R.NOME AS RESPONSAVEL, R.CPF AS CPF_RESPONSAVEL
FROM ALUNOS A
INNER HASH JOIN RESPONSAVEIS R ON (A.ID_RESPONSAVEL = R.ID)
WHERE A.ID = 1;
GO


--EXEMPLO 04 (PARALELISMO)

SELECT A.NOME AS ALUNO, A.SEXO AS SEXO_ALUNO, R.NOME AS RESPONSAVEL, R.CPF AS CPF_RESPONSAVEL
FROM ALUNOS A
INNER LOOP JOIN RESPONSAVEIS R ON (A.ID_RESPONSAVEL = R.ID);
GO

SET STATISTICS TIME ON;
GO

SELECT A.NOME AS ALUNO, A.SEXO AS SEXO_ALUNO, R.NOME AS RESPONSAVEL, R.CPF AS CPF_RESPONSAVEL
FROM ALUNOS A
INNER HASH JOIN RESPONSAVEIS R ON (A.ID_RESPONSAVEL = R.ID)
OPTION(USE HINT('ENABLE_PARALLEL_PLAN_PREFERENCE'));
GO


--EXEMPLO 05

SELECT ANO, LETRA, ENSINO
FROM TURMAS
WHERE ANO = '1'
GO

CREATE NONCLUSTERED INDEX IDX_TURMAS_001 ON TURMAS(ANO);
GO

SELECT ANO, LETRA, ENSINO
FROM TURMAS
WHERE ANO = '1'
GO

SELECT ANO, COUNT(*)
FROM TURMAS
GROUP BY ANO
ORDER BY ANO;


SELECT ANO, LETRA, ENSINO
FROM TURMAS
WHERE ANO = '6'
GO

SELECT ANO, LETRA, ENSINO
FROM TURMAS
WHERE ANO = '7'
GO

SET STATISTICS IO ON;
GO

SELECT ANO, LETRA, ENSINO
FROM TURMAS
WHERE ANO = '7'
GO


--EXEMPLO 06

SELECT ID_TURMA, DATA_MATRICULA
FROM MATRICULAS
WHERE ID_ALUNO = 1;
GO

--VER O ÍNDICE SUGERIDO
SELECT ID_TURMA, DATA_MATRICULA
FROM MATRICULAS
WHERE ID_ALUNO BETWEEN 1 AND 500;
GO

SELECT ID_TURMA, DATA_MATRICULA
FROM MATRICULAS
WHERE ID_ALUNO BETWEEN 1 AND 250;
GO

SELECT ID_TURMA, DATA_MATRICULA
FROM MATRICULAS
WHERE ID_ALUNO BETWEEN 1 AND 125;
GO

SELECT ID_TURMA, DATA_MATRICULA
FROM MATRICULAS
WHERE ID_ALUNO BETWEEN 1 AND 50;
GO

SELECT ID_TURMA, DATA_MATRICULA
FROM MATRICULAS
WHERE ID_ALUNO BETWEEN 1 AND 25;
GO

SELECT ID_TURMA, DATA_MATRICULA
FROM MATRICULAS
WHERE ID_ALUNO BETWEEN 1 AND 10;
GO

SELECT ID_TURMA, DATA_MATRICULA
FROM MATRICULAS
WHERE ID_ALUNO BETWEEN 1 AND 20;
GO

SELECT ID_TURMA, DATA_MATRICULA
FROM MATRICULAS
WHERE ID_ALUNO BETWEEN 1 AND 15;
GO

--CONSTRAINT UNQ_MATRICULAS_ALUNO_TURMA UNIQUE(ID_ALUNO,ID_TURMA)

/*
CREATE NONCLUSTERED INDEX [<Name of Missing Index, sysname,>]
ON [dbo].[MATRICULAS] ([ID_ALUNO])
INCLUDE ([ID_TURMA],[DATA_MATRICULA])
*/

SET STATISTICS IO OFF;
GO
SET STATISTICS TIME OFF;
GO


--EXEMPLO 07 (COVERING INDEX)

SELECT ID_TURMA, DATA_MATRICULA
FROM MATRICULAS
WHERE ID_ALUNO BETWEEN 1 AND 500;

CREATE NONCLUSTERED INDEX IDX_MATRICULAS_COVERING
ON [dbo].[MATRICULAS] ([ID_ALUNO])
INCLUDE ([ID_TURMA],[DATA_MATRICULA]);
GO

SELECT ID_TURMA, DATA_MATRICULA
FROM MATRICULAS
WHERE ID_ALUNO BETWEEN 1 AND 500;
GO

SELECT ID_TURMA, DATA_MATRICULA
FROM MATRICULAS
WHERE ID_ALUNO BETWEEN 1 AND 1000;
GO

SELECT ID_TURMA, DATA_MATRICULA
FROM MATRICULAS
WHERE ID_ALUNO BETWEEN 1 AND 3000;
GO

DROP INDEX IDX_MATRICULAS_COVERING ON [dbo].[MATRICULAS];
GO


--EXEMPLO 08

--VER O PLANO DE EXECUÇÃO REAL
SELECT A.NOME AS ALUNO, A.SEXO AS SEXO_ALUNO, A.DATA_NASCIMENTO
FROM ALUNOS A
INNER JOIN RESPONSAVEIS R ON (R.ID = A.ID_RESPONSAVEL)
INNER JOIN MATRICULAS M ON (M.ID_ALUNO = A.ID)
INNER JOIN TURMAS T ON (T.ID = M.ID_TURMA)
GO

--CONSTRAINT CHK_RESPONSAVEIS_SEXO CHECK(SEXO IN('M','F'))

SET STATISTICS IO ON

SELECT *
FROM RESPONSAVEIS
WHERE SEXO = 'X'; --PARAMETERIZATION
GO


DECLARE @VAR CHAR(1) = 'X'

SELECT *
FROM RESPONSAVEIS
WHERE SEXO = @VAR
OPTION(RECOMPILE)
GO

--VER O PLANO ESTIMADO
SELECT *
FROM ALUNOS
WHERE ID = 1;
GO


--FKs

--ALGO ESTRANHO COM O PLANO DE EXECUÇÃO?
SELECT A.NOME AS ALUNO, A.SEXO AS SEXO_ALUNO, A.DATA_NASCIMENTO
FROM ALUNOS A
INNER JOIN RESPONSAVEIS R ON (R.ID = A.ID_RESPONSAVEL)
INNER JOIN MATRICULAS M ON (M.ID_ALUNO = A.ID)
GO

ALTER TABLE ALUNOS
DROP CONSTRAINT FK_ALUNOS_RESPONSAVEIS;
GO

SELECT A.NOME AS ALUNO, A.SEXO AS SEXO_ALUNO, A.DATA_NASCIMENTO
FROM ALUNOS A
INNER JOIN RESPONSAVEIS R ON (R.ID = A.ID_RESPONSAVEL)
INNER JOIN MATRICULAS M ON (M.ID_ALUNO = A.ID)
GO

ALTER TABLE ALUNOS ADD CONSTRAINT FK_ALUNOS_RESPONSAVEIS FOREIGN KEY(ID_RESPONSAVEL)
REFERENCES RESPONSAVEIS(ID);
GO

SELECT A.NOME AS ALUNO, A.SEXO AS SEXO_ALUNO, A.DATA_NASCIMENTO
FROM ALUNOS A
INNER JOIN RESPONSAVEIS R ON (R.ID = A.ID_RESPONSAVEL)
INNER JOIN MATRICULAS M ON (M.ID_ALUNO = A.ID)
GO


--EXEMPLO 09

SELECT *
FROM ALUNOS;
GO

SELECT *
FROM ALUNOS OPTION(FAST 10);
GO

SELECT *
FROM ALUNOS
ORDER BY DATA_NASCIMENTO;
GO

SELECT *
FROM ALUNOS
ORDER BY DATA_NASCIMENTO
OPTION(FAST 10);
GO

SELECT ID, NOME
FROM ALUNOS
WHERE SEXO = 'M'
ORDER BY DATA_NASCIMENTO;
GO

CREATE NONCLUSTERED INDEX IDX_ALUNOS_SEXO ON ALUNOS(SEXO) INCLUDE(ID,NOME);  --NAO PRECISAVA DO ID AQUI
GO

SELECT ID, NOME
FROM ALUNOS
WHERE SEXO = 'M'
ORDER BY DATA_NASCIMENTO;
GO


DROP INDEX IDX_ALUNOS_SEXO ON ALUNOS;
GO

CREATE NONCLUSTERED INDEX IDX_ALUNOS_SEXO ON ALUNOS(SEXO) INCLUDE(DATA_NASCIMENTO,ID,NOME);  --NAO PRECISAVA DO ID AQUI
GO

SELECT ID, NOME
FROM ALUNOS
WHERE SEXO = 'M'
ORDER BY DATA_NASCIMENTO;
GO

DROP INDEX IDX_ALUNOS_SEXO ON ALUNOS;
GO

CREATE NONCLUSTERED INDEX IDX_ALUNOS_SEXO ON ALUNOS(SEXO,DATA_NASCIMENTO) INCLUDE(ID,NOME);  --NAO PRECISAVA DO ID AQUI
GO

SELECT ID, NOME
FROM ALUNOS
WHERE SEXO = 'M'
ORDER BY DATA_NASCIMENTO;
GO

DROP INDEX IDX_ALUNOS_SEXO ON ALUNOS;
GO

SELECT ID, NOME
FROM ALUNOS
WHERE SEXO = 'M'
AND ID_RESPONSAVEL = 3
ORDER BY DATA_NASCIMENTO;
GO

--A ORDEM DE SEXO & DATA_NASCIMENTO, IMPORTA?
CREATE NONCLUSTERED INDEX IDX_ALUNOS_SEXO ON ALUNOS(SEXO,ID_RESPONSAVEL,DATA_NASCIMENTO) INCLUDE(ID,NOME);  --NAO PRECISAVA DO ID AQUI
GO

SELECT ID, NOME
FROM ALUNOS
WHERE SEXO = 'M'
AND ID_RESPONSAVEL = 3
ORDER BY DATA_NASCIMENTO;
GO

SELECT ID, NOME
FROM ALUNOS
WHERE SEXO = 'M'
ORDER BY DATA_NASCIMENTO;
GO

SELECT ID, NOME
FROM ALUNOS
WHERE ID_RESPONSAVEL = 3
ORDER BY DATA_NASCIMENTO;
GO


--EXEMPLO 10

--O TIPO DE DADOS DA CHAVE DO ÍNDICE CLUSTER E O NÚMERO DE CAMPOS DA CHAVE, INFLUENCIAM EM ALGO?

TINYINT - 1 BYTE
SMALLINT - 2 BYTES
INTEGER - 4 BYTES
BIGINT - 8 BYTES


--EXEMPLO 11

--TIPOS "FIXOS" x TIPOS "VARIÁVEIS"
--COLUNAS QUE ACEITAM NULL
--UNIQUE x NON-UNIQUE


--EXEMPLO 12

--QUAL O IMPACTO NEGATIVO DE SELECT * ??