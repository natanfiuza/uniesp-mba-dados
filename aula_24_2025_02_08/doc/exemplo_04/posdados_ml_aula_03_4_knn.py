# -*- coding: utf-8 -*-
"""PosDados_ML - Aula 03.4 - KNN.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qh0rpz_hYMQcHT05TmTFhXDR2p6kc_ex

## **Importando os dados**
"""

from sklearn.datasets import load_iris
import pandas as pd

iris = load_iris()

# print(iris.target)
# print(iris.target_names)

type(iris.data)

iris_x = pd.DataFrame(
    data=iris.data,
    columns=[
        "sepala_comprimento", "sepala_largura",
        "petala_comprimento", "petala_largura"])

iris_x

"""## **Segmentar a Amostra?**"""

# from sklearn.model_selection import train_test_split
# treino_X, teste_X, treino_Y, teste_Y = train_test_split(
#    iris, test_size=0.3, random_state=4)

# Aprendizagem não-supervisionada (Sem treino)

"""## **Criando o Modelo Não Supervisionado**

### **KNN**
"""

from sklearn.neighbors import NearestNeighbors

#Criação do Modelo
model = NearestNeighbors(n_neighbors=3, algorithm='auto') #default 5 grupos
# ['auto', 'ball_tree', 'tmokd_tree', 'brute'] - auto ele escolhe o melhor algoritmo

#Identificação dos grupos
model.fit(iris_x)

distances, indices = model.kneighbors(iris_x)

# print(indices)
print(distances)

model.kneighbors_graph(iris_x).toarray()

"""## KMeans"""

from sklearn.cluster import KMeans

kmeans = KMeans(n_clusters=3, random_state=0).fit(iris_x)
kmeans.labels_

kmeans.cluster_centers_

"""## **Definir o melhor valor para K**

### **Técnica do Joelho ou do Cotovelo (Knee or Elbow)**
"""

from yellowbrick.cluster import KElbowVisualizer

model_G = KMeans()
visualizer = KElbowVisualizer(model_G, k=(1,12))

visualizer.fit(iris_x)
visualizer.show()

"""## **Visualização dos grupos**"""

import numpy as np

from matplotlib import pyplot as plt
from scipy.cluster.hierarchy import dendrogram
from sklearn.cluster import AgglomerativeClustering

iris_x = pd.DataFrame(
    data=iris.data,
    columns=[
             "sepala_comprimento", "sepala_largura",
             "petala_comprimento", "petala_largura"])

def plot_dendrogram(model, **kwargs):
    counts = np.zeros(model.children_.shape[0])
    n_samples = len(model.labels_)
    for i, merge in enumerate(model.children_):
        current_count = 0
        for child_idx in merge:
            if child_idx < n_samples:
                current_count += 1
            else:
                current_count += counts[child_idx - n_samples]
        counts[i] = current_count

    linkage_matrix = np.column_stack([model.children_, model.distances_,
                                      counts]).astype(float)

    # Plot the corresponding dendrogram
    dendrogram(linkage_matrix, **kwargs)


# setting distance_threshold=0 ensures we compute the full tree.
modelAg = AgglomerativeClustering(
    distance_threshold=5, n_clusters=None)

modelAg = modelAg.fit(iris_x)
plt.title('Hierarchical Clustering Dendrogram')

# plot the top three levels of the dendrogram
plot_dendrogram(modelAg, truncate_mode='level', p=3)
plt.xlabel("Number of points in node (or index of point if no parenthesis).")
plt.show()

modelAg.n_clusters_

modelAg.labels_