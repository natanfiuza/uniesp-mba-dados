USE DISCIPLINA02
GO

SELECT *
FROM CLIENTES;
GO


SELECT NOME + ' DA SILVA' AS NOME_CLIENTE, CPF, SEXO, IDLOGRADOURO, IDCLIENTE + 1 AS ID
FROM CLIENTES
WHERE SEXO = 'M';
GO

SELECT NOME + ' DA SILVA' AS NOME_CLIENTE, CPF, SEXO, IDLOGRADOURO, IDCLIENTE + 1 AS ID
FROM CLIENTES
WHERE SEXO = 'M' AND IDLOGRADOURO > 100;
GO

SELECT NOME + ' DA SILVA' AS NOME_CLIENTE, CPF, SEXO, IDLOGRADOURO, IDCLIENTE + 1 AS ID
FROM CLIENTES
WHERE SEXO = 'M' AND IDLOGRADOURO > 100 AND ID < 50;
GO

SELECT NOME + ' DA SILVA' AS NOME_CLIENTE, CPF, SEXO, IDLOGRADOURO, IDCLIENTE + 1 AS ID
FROM CLIENTES
WHERE SEXO = 'M' OR IDLOGRADOURO > 100 OR IDCLIENTE < 50;
GO

SELECT NOME + ' DA SILVA' AS NOME_CLIENTE, CPF, SEXO, IDLOGRADOURO, IDCLIENTE + 1 AS ID
FROM CLIENTES
WHERE (SEXO = 'M' AND IDLOGRADOURO > 100) OR IDCLIENTE < 50;
GO

----LISTANDO DADOS DE MAIS DE UMA TABELA

SELECT C.IDCLIENTE, C.NOME, V.DATA
FROM CLIENTES C
INNER JOIN VENDAS V ON (V.IDCLIENTE = C.IDCLIENTE);
GO


SELECT C.IDCLIENTE, C.NOME, V.DATA
FROM CLIENTES C 
LEFT OUTER JOIN VENDAS V ON (V.IDCLIENTE = C.IDCLIENTE);
GO

--QUAL A DIFERENÇA DO COMANDO ANTERIOR?
SELECT C.IDCLIENTE, C.NOME, V.DATA
FROM VENDAS V 
RIGHT OUTER JOIN CLIENTES C ON (V.IDCLIENTE = C.IDCLIENTE);
GO



SELECT C.IDCLIENTE, C.NOME, V.DATA
FROM CLIENTES C
RIGHT OUTER JOIN VENDAS V ON (V.IDCLIENTE = C.IDCLIENTE);
GO


--EQUIVALENTE A QUAL QUE NÓS FIZEMOS ANTES?
SELECT C.IDCLIENTE, C.NOME, V.DATA
FROM CLIENTES C
FULL OUTER JOIN VENDAS V ON (V.IDCLIENTE = C.IDCLIENTE);
GO



/*
LISTE O NOME DO CLIENTE, SEU CPF, DATA DA VENDA, NOME DO PRODUTO,
VALOR ATUAL DO PRODUTO E VALOR DO PRODUTO NO DIA DA VENDA,
DE TODOS AS VENDAS DE CLIENTES DO SEXO FEMININO
*/

SELECT C.NOME AS CLIENTE, C.CPF, V.DATA AS DATA_VENDA, P.PRODUTO, 
P.VALOR AS VALOR_ATUAL, IV.VALOR AS VALOR_VENDA
FROM CLIENTES C
INNER JOIN VENDAS V ON (C.IDCLIENTE = V.IDCLIENTE)
INNER JOIN ITENS_VENDAS IV ON (V.IDVENDA = IV.IDVENDA)
INNER JOIN PRODUTOS P ON (P.IDPRODUTO = IV.IDPRODUTO)
WHERE SEXO = 'F';
GO


/*
FAÇA A MESMA CONSULTA ANTERIOR, MAS AGORA CALCULANDO
A VARIAÇÃO (EM %) DO PREÇO DO PRODUTO
OU SEJA, DO DIA DA COMPRA ATÉ O DIA ATUAL
*/

SELECT C.NOME, C.CPF, V.DATA, P.PRODUTO, IV.VALOR AS VAL_VENDA,
P.VALOR AS VAL_PROD
,(P.VALOR / IV.VALOR) * 100 AS COMPARACAO
,((P.VALOR / IV.VALOR)-1) * 100 AS VARIACAO
FROM CLIENTES AS C
INNER JOIN VENDAS AS V ON (C.IDCLIENTE = V.IDCLIENTE)
INNER JOIN ITENS_VENDAS AS IV ON (IV.IDVENDA = V.IDVENDA)
INNER JOIN PRODUTOS AS P ON (IV.IDPRODUTO = P.IDPRODUTO)
WHERE C.SEXO = 'F'

/*
FAÇA O MESMO DA CONSULTA ANTERIOR, EXIBINDO APENAS
OS PRODUTOS QUE TIVERAM UM AUMENTO DE PREÇO MAIOR QUE 100%
*/


SELECT C.NOME, C.CPF, V.DATA, P.PRODUTO, IV.VALOR AS VAL_VENDA,
P.VALOR AS VAL_PROD
,(P.VALOR / IV.VALOR) * 100 AS COMPARACAO
,((P.VALOR / IV.VALOR)-1) * 100 AS VARIACAO
FROM CLIENTES AS C
INNER JOIN VENDAS AS V ON (C.IDCLIENTE = V.IDCLIENTE)
INNER JOIN ITENS_VENDAS AS IV ON (IV.IDVENDA = V.IDVENDA)
INNER JOIN PRODUTOS AS P ON (IV.IDPRODUTO = P.IDPRODUTO)
WHERE C.SEXO = 'F'
AND ((P.VALOR / IV.VALOR)-1) * 100 > 100


---ORDENANDO OS DADOS
SELECT *
FROM CLIENTES
ORDER BY SEXO;
GO


SELECT *
FROM CLIENTES
ORDER BY SEXO, IDLOGRADOURO;
GO

--COMBINANDO ORDENAÇÃO E FILTRO?
SELECT *
FROM CLIENTES
WHERE SEXO = 'M'
ORDER BY IDLOGRADOURO;
GO


--E O * NESSE CASO, O QUE FAZ?
SELECT *
FROM CLIENTES C
INNER JOIN VENDAS V ON (C.IDCLIENTE = V.IDCLIENTE);
GO


SELECT C.IDCLIENTE, V.*
FROM CLIENTES C
INNER JOIN VENDAS V ON (C.IDCLIENTE = V.IDCLIENTE);
GO


SELECT C.*, V.DATA
FROM CLIENTES C
INNER JOIN VENDAS V ON (C.IDCLIENTE = V.IDCLIENTE);
GO

SELECT C.*, V.*
FROM CLIENTES C
INNER JOIN VENDAS V ON (C.IDCLIENTE = V.IDCLIENTE);
GO


SELECT P.*, C.*
FROM CLIENTES C
INNER JOIN VENDAS V ON (C.IDCLIENTE = V.IDCLIENTE)  --INNER JOIN SERVINDO DE "FILTRO"
INNER JOIN ITENS_VENDAS IV ON (V.IDVENDA = IV.IDVENDA)
INNER JOIN PRODUTOS P ON (P.IDPRODUTO = IV.IDPRODUTO);  --PARA CHEGAR EM PRODUTOS, PRECISO PASSAR POR VENDAS E ITENS_VENDAS
GO


SELECT P.*, C.*
FROM CLIENTES C
INNER JOIN VENDAS V ON (C.IDCLIENTE = V.IDCLIENTE AND V.DATA >= '20150101')  --INNER JOIN SERVINDO DE "FILTRO"
INNER JOIN ITENS_VENDAS IV ON (V.IDVENDA = IV.IDVENDA)
INNER JOIN PRODUTOS P ON (P.IDPRODUTO = IV.IDPRODUTO);  --PARA CHEGAR EM PRODUTOS, PRECISO PASSAR POR VENDAS E ITENS_VENDAS
GO


--QUAL A DIFERENÇA?
SELECT P.*, C.*
FROM CLIENTES C
INNER JOIN VENDAS V ON (C.IDCLIENTE = V.IDCLIENTE)  --INNER JOIN SERVINDO DE "FILTRO"
INNER JOIN ITENS_VENDAS IV ON (V.IDVENDA = IV.IDVENDA)
INNER JOIN PRODUTOS P ON (P.IDPRODUTO = IV.IDPRODUTO)  --PARA CHEGAR EM PRODUTOS, PRECISO PASSAR POR VENDAS E ITENS_VENDAS
WHERE V.DATA >= '20150101';
GO



--EXIBA O ITEM VENDA DE MAIOR QUANTIDADE DE ITENS
SELECT TOP 1 *
FROM ITENS_VENDAS;
GO


SELECT TOP 1 *
FROM ITENS_VENDAS
ORDER BY QUANTIDADE DESC;  --ASC / DESC
GO

SELECT TOP (1) *
FROM ITENS_VENDAS
ORDER BY QUANTIDADE DESC;  --ASC / DESC
GO


--FAÇO O MESMO DO ITEM ANTERIOR, MAS EM CASO DE EMPATE DE DOIS ITENS_VENDAS DE MESMA QUANTIDADE, DESEMPATE LISTANDO O ITEM DE MENOR VALOR
SELECT TOP 1 *
FROM ITENS_VENDAS
ORDER BY QUANTIDADE DESC

SELECT TOP 1 *
FROM ITENS_VENDAS
ORDER BY QUANTIDADE DESC, VALOR ASC


--LISTAR OS 20 PRIMEIROS CLIENTES, EM ORDEM ALFABÉTICA
SELECT TOP 20 *
FROM CLIENTES
ORDER BY NOME;  --ASC
GO

--E SE EU QUISER "PAGINAR"?
--LISTANDO OS 20 PRIMEIROS
--A PARTIR DO SQL SERVER 2012!
SELECT *
FROM CLIENTES
ORDER BY NOME
OFFSET 0 ROWS
FETCH NEXT 20 ROWS ONLY;
GO

--E PARA LISTAR OS 20 SEGUINTES?!
--OFFSET / FETCH RESOLVE!
SELECT *
FROM CLIENTES
ORDER BY NOME
OFFSET 20 ROWS
FETCH NEXT 20 ROWS ONLY;
GO

DECLARE  @PULE INT = 20, @QTDE INT = 20

SELECT *
FROM CLIENTES
ORDER BY NOME
OFFSET @PULE ROWS
FETCH NEXT @QTDE ROWS ONLY;
GO

-----SE NAO FEZ EXERCICIO1, FAZER AGORA :D

-----EXERCÍCIO 02!


--NO SQL SERVER 2008 E ANTERIORES
;WITH CLIENTES_PAGINADOS(IDCLIENTE,NOME,CPF,SEXO,IDLOGRADOURO, POSICAO)
AS
(
	SELECT IDCLIENTE,NOME,CPF,SEXO,IDLOGRADOURO, ROW_NUMBER() OVER (ORDER BY NOME) AS POSICAO
	FROM CLIENTES
)
SELECT *
FROM CLIENTES_PAGINADOS
WHERE POSICAO BETWEEN 21 AND 40
GO



/*
	LISTA A QUANTIDADE TOTAL DE ITENS (SOMA DAS QUANTIDADES DE CADA ITEM DA VENDA) POR VENDA, DE TODAS AS VENDAS
*/

--FUNÇÕES DE AGREGAÇÃO: COUNT, SUM, AVG, MIN, MAX

SELECT IV.IDVENDA, SUM(IV.QUANTIDADE) AS QTDE, SUM(IV.VALOR) AS SOMA_VALORES
FROM ITENS_VENDAS AS IV
GROUP BY IV.IDVENDA



/*
	FAÇA O MESMO DO ITEM ANTERIOR, AGORA EXIBINDO TAMBÉM A DATA DA VENDA
*/

SELECT IV.IDVENDA, V.DATA, SUM(IV.QUANTIDADE) AS QTDE
FROM ITENS_VENDAS AS IV
INNER JOIN VENDAS AS V ON (V.IDVENDA = IV.IDVENDA)
GROUP BY IV.IDVENDA, V.DATA


/*
FAÇA O MESMO DO ITEM ANTERIOR, AGORA EXIBINDO APENAS
AQUELAS VENDAS QUE TIVERAM MAIS QUE 100 ITENS E ORDENANDO O
RESULTADO PELA QUANTIDADE DE FORMA DECRESCENTE
*/

SELECT IV.IDVENDA, V.DATA, SUM(IV.QUANTIDADE) AS QTDE
FROM ITENS_VENDAS AS IV
INNER JOIN VENDAS AS V ON (V.IDVENDA = IV.IDVENDA)
GROUP BY IV.IDVENDA, V.DATA
HAVING SUM(IV.QUANTIDADE) > 100
ORDER BY QTDE DESC



/*
LISTE NOME, CPF E DATA DE CONTRATAÇÃO DOS FUNCIONÁRIOS,
INFORMANDO TAMBÉM LOGRADOURO, CEP, NOME DO BAIRRO,
NOME DA CIDADE,SIGLA DA UF, ORDENADOS PELO NOME EM
FORMA ASCENDENTE
*/


SELECT F.NOME, F.CPF, F.DT_CONTRATACAO,
L.LOGRADOURO, L.CEP, B.BAIRRO, C.CIDADE, U.UF
FROM FUNCIONARIOS AS F
INNER JOIN LOGRADOUROS AS L ON (F.IDLOGRADOURO = L.IDLOGRADOURO)
INNER JOIN BAIRROS AS B ON (B.IDBAIRRO = L.IDBAIRRO)
INNER JOIN CIDADES AS C ON  (C.IDCIDADE = B.IDCIDADE)
INNER JOIN UFS AS U ON (U.IDUF = C.IDUF)
ORDER BY F.NOME ASC



/*
FAÇA A MESMA CONSULTA DE ANTES, MAS AGORA ADICIONANDO A UF DO RG
*/

SELECT F.NOME, F.CPF, F.DT_CONTRATACAO,
L.LOGRADOURO, L.CEP, B.BAIRRO, C.CIDADE, U.UF, U_RG.UF AS UF_RG
FROM FUNCIONARIOS AS F
INNER JOIN LOGRADOUROS AS L ON (F.IDLOGRADOURO = L.IDLOGRADOURO)
INNER JOIN BAIRROS AS B ON (B.IDBAIRRO = L.IDBAIRRO)
INNER JOIN CIDADES AS C ON  (C.IDCIDADE = B.IDCIDADE)
INNER JOIN UFS AS U ON (U.IDUF = C.IDUF)
INNER JOIN UFS AS U_RG ON (F.IDUF_RG = U_RG.IDUF)
ORDER BY F.NOME ASC



--DIMINUA EM 10% O VALOR DOS ITENS DE VENDAS DE TODOS OS CLIENTES DO SEXO MASCULINO

UPDATE ITENS_VENDAS
SET VALOR = VALOR * 0.9
WHERE EXISTS(  --SUB-CONSULTA
	SELECT 1
	FROM CLIENTES AS C
	INNER JOIN VENDAS AS V ON (V.IDCLIENTE = C.IDCLIENTE)
	WHERE V.IDVENDA = ITENS_VENDAS.IDVENDA
	AND C.SEXO = 'M'
);
GO

UPDATE ITENS_VENDAS
SET VALOR = VALOR * 0.9
FROM ITENS_VENDAS AS IV
INNER JOIN VENDAS AS V ON (V.IDVENDA = IV.IDVENDA)
INNER JOIN CLIENTES AS C ON (C.IDCLIENTE = V.IDCLIENTE)
WHERE C.SEXO = 'M';
GO



--REMOVA AS VENDAS DO CLIENTE DE ID 78
DELETE FROM VENDAS
WHERE IDCLIENTE = 78


--REMOVA AS VENDAS QUE TIVERAM O PRODUTO DE CODIGO 2151

DELETE VENDAS
FROM VENDAS V
INNER JOIN ITENS_VENDAS IV ON (IV.IDVENDA = V.IDVENDA)
WHERE IV.IDPRODUTO = 2151


--SUB-CONSULTAS

/*
	LISTE OS DADOS DO CLIENTE QUE FEZ A MAIOR QUANTIDADE DE COMPRAS
*/
SELECT *
FROM CLIENTES C
WHERE C.IDCLIENTE = (
	SELECT TOP 1 V.IDCLIENTE
	FROM VENDAS V
	GROUP BY V.IDCLIENTE
	ORDER BY COUNT(*) DESC
)


/*  --LISTAR UM PRODUTO QUE NÃO ESTEJA EM NENHUMA VENDA
SELECT * FROM PRODUTOS P
WHERE NOT EXISTS(
	SELECT *
	FROM ITENS_VENDAS IV
	WHERE P.IDPRODUTO = IV.IDPRODUTO
);
*/


--FUNÇÕES DE STRING
DECLARE @VAR VARCHAR(28) -- = ' ABCDEFGHIJKLMNOPQRSTUVWXYZ '
SET @VAR = ' ABCDEFGHIJKLMNOPQRSTUVWXYZ '
--SELECT @VAR = ' ABCDEFGHIJKLMNOPQRSTUVWXYZ '

SELECT 
LEFT(@VAR,4) AS [LEFT], RIGHT(@VAR,4) AS [RIGHT], LEN(@VAR) AS LEN, CONCAT(@VAR,NULL,@VAR) AS CONCAT, LTRIM(@VAR) AS LTRIM, 
RTRIM(@VAR) AS RTRIM, SUBSTRING(@VAR, 3, 4) AS SUBSTRING, LOWER(@VAR) AS LOWER, UPPER('aaaa') AS UPPER,
QUOTENAME(@VAR) AS QUOTENAME1, QUOTENAME(@VAR,'''') AS QUOTENAME2;

--FUNÇÕES DE DATETIME

SELECT GETDATE(), DAY(GETDATE()), MONTH(GETDATE()), YEAR(GETDATE()), DATEADD(d,1,GETDATE());

--FUNÇÕES MATEMÁTICAS
--https://docs.microsoft.com/pt-br/sql/t-sql/functions/mathematical-functions-transact-sql?view=sql-server-ver15



--FUNÇÕES DE "RANQUEAMENTO"
SELECT C.NOME, V.DATA
    ,ROW_NUMBER() OVER (ORDER BY V.DATA ASC) AS "Row Number"
    ,RANK() OVER (ORDER BY V.DATA ASC, C.NOME DESC) AS Rank
    ,DENSE_RANK() OVER (ORDER BY V.DATA ASC) AS "Dense Rank"
    ,NTILE(4) OVER (ORDER BY V.DATA ASC) AS Quartile
FROM CLIENTES AS C
INNER JOIN VENDAS AS V ON (V.IDCLIENTE = C.IDCLIENTE);





/* COMANDO APPLY:

LISTE O NOME DE CADA CLIENTE QUE JÁ TENHA FEITO ALGUMA COMPRA E A DATA DE SUA PRIMEIRA COMPRA, ORDENADOS PELO NOME DO CLIENTE E, POSTERIORMENTE, 
PELA DATA DA VENDA(COMPRA), AMBOS EM ORDEM ASCENDENTE
*/

SELECT C.NOME, MIN(V.DATA)
FROM CLIENTES C
INNER JOIN VENDAS V ON (V.IDCLIENTE = C.IDCLIENTE)
GROUP BY C.IDCLIENTE
ORDER BY C.NOME, MIN(V.DATA)
GO

SELECT C.NOME, MIN(V.DATA)
FROM CLIENTES C
INNER JOIN VENDAS V ON (V.IDCLIENTE = C.IDCLIENTE)
GROUP BY C.IDCLIENTE, C.NOME
ORDER BY C.NOME ASC, MIN(V.DATA) ASC;
GO


SELECT C.NOME, PRIMEIRA_VENDA.DATA AS DT_PRIMEIRA_VENDA, PRIMEIRA_VENDA.IDVENDA
FROM CLIENTES AS C
CROSS APPLY(  --MESMA IDEIA DO "INNER JOIN"
	SELECT TOP 1 V.DATA, V.IDVENDA
	FROM VENDAS AS V
	WHERE V.IDCLIENTE = C.IDCLIENTE
	ORDER BY V.DATA ASC
) AS PRIMEIRA_VENDA
ORDER BY 1, 2;

--E AGORA???
SELECT C.NOME, MIN(V.DATA), V.IDVENDA
FROM CLIENTES C
INNER JOIN VENDAS V ON (V.IDCLIENTE = C.IDCLIENTE)
GROUP BY C.IDCLIENTE, C.NOME, V.IDVENDA
ORDER BY C.NOME ASC, MIN(V.DATA) ASC;
GO


/*
LISTE O NOME DE CADA CLIENTE, TENDO ELE JÁ FEITO ALGUMA COMPRA OU NÃO, E A DATA DE SUA PRIMEIRA COMPRA, CASO HAJA, ORDENADOS PELO NOME DO CLIENTE E, POSTERIORMENTE, 
PELA DATA DA VENDA, AMBOS EM ORDEM ASCENDENTE
*/

SELECT C.NOME, PRIMEIRA_VENDA.DATA AS DT_PRIMEIRA_VENDA
FROM CLIENTES AS C
OUTER APPLY(  --MESMA IDEIA DO "OUTER JOIN"
	SELECT TOP 1 V.DATA
	FROM VENDAS AS V
	WHERE V.IDCLIENTE = C.IDCLIENTE
	ORDER BY V.DATA ASC
) AS PRIMEIRA_VENDA
ORDER BY 1, 2;


----COMMON TABLE EXPRESSIONS (CTE)

--LISTE A QUANTIDADE DE VENDAS, POR CLIENTE POR ANO, ORDENADOS PELO CLIENTE E, EM SEGUIDA, POR ANO
;WITH TABELA(VENDA, ANO, CLIENTE)  --NOMES DE COLUNAS SAO OPCIONAIS
AS
(
	SELECT V.IDVENDA, YEAR(V.DATA) AS ANO, V.IDCLIENTE
	FROM VENDAS AS V
	--ORDER BY V.IDCLIENTE  <--- NÃO PODE USAR ORDER BY, SALVO COM USO DO TOP
)
SELECT CLIENTE, COUNT(*) AS QTDE, ANO
FROM TABELA
GROUP BY ANO, CLIENTE
ORDER BY CLIENTE, ANO;



--LISTE O MAIOR TOTAL ANUAL DE COMPRAS, POR CLIENTE
;WITH TABELA(ANO, CLIENTE, TOTAL) AS
(
	SELECT YEAR(V.DATA) AS ANO, V.IDCLIENTE, SUM(IV.VALOR) AS TOTAL  --AVG, MAX, MIN, COUNT, COUNT_BIG
	FROM VENDAS AS V
	INNER JOIN ITENS_VENDAS AS IV ON (V.IDVENDA = IV.IDVENDA)
	GROUP BY V.IDCLIENTE, YEAR(V.DATA)
	--ORDER BY V.IDCLIENTE
)
SELECT CLIENTE, MAX(TOTAL) AS MAIOR
FROM TABELA
GROUP BY CLIENTE
ORDER BY CLIENTE, MAIOR;
GO



-----EXEMPLOS "EXTRAS"

CREATE TABLE #TEMP(
	ID INT NOT NULL,
	NOME VARCHAR(100)
)

INSERT INTO #TEMP
(ID,NOME)
VALUES
(1,'ANTONIO');
GO

SELECT *
FROM #TEMP;
GO

DROP TABLE #TEMP;
GO

SELECT TOP 10 *, 1+1 AS ID
INTO #CLIENTES
FROM CLIENTES;
GO

SELECT *
FROM #CLIENTES;
GO


--GERAR UMA TABELA CHAMADA "PRODUTOS_NOVOS" COM A MESMA ESTRUTURA DE "PRODUTOS"
SELECT IDPRODUTO, PRODUTO AS PRODUTO_NOVO, VALOR AS VALOR_NOVO
INTO PRODUTOS_NOVOS
FROM PRODUTOS
WHERE 1=2;
GO

SELECT *
FROM PRODUTOS_NOVOS;
GO

DROP TABLE PRODUTOS_NOVOS;
GO


SELECT PRODUTO AS PRODUTO_NOVO, VALOR AS VALOR_NOVO
INTO PRODUTOS_NOVOS
FROM PRODUTOS
WHERE 1=2;
GO




INSERT INTO PRODUTOS_NOVOS
SELECT PRODUTO, VALOR  --MESMO NOME E MESMO VALOR
FROM PRODUTOS
WHERE IDPRODUTO = 1;
GO

INSERT INTO PRODUTOS_NOVOS
SELECT PRODUTO, VALOR+1  --MESMO NOME E VALOR DIFERENTE
FROM PRODUTOS
WHERE IDPRODUTO = 2;
GO

INSERT INTO PRODUTOS_NOVOS
SELECT 'NOVO_PRODUTO01',1000;  --NOME DIFERENTE
GO

SELECT *
FROM PRODUTOS_NOVOS;
GO

SELECT *
FROM PRODUTOS;
GO

--CARREGUE OS PRODUTOS DA TABELA "PRODUTOS_NOVOS" DE ACORDO COM A REGRA ABAIXO
/*
	PRODUTOS DE MESMO NOME DEVEM TER O VALOR ATUALIZADO
	PRODUTOS CUJO NOME NÃO EXISTA, DEVEM SER INSERIDOS
*/
MERGE PRODUTOS AS target
    USING (SELECT PRODUTO_NOVO, VALOR_NOVO FROM PRODUTOS_NOVOS) AS source (PRODUTO, VALOR)
    ON (target.PRODUTO = source.PRODUTO)
    WHEN MATCHED THEN 
        UPDATE SET VALOR = source.VALOR
	WHEN NOT MATCHED THEN
		INSERT (PRODUTO, VALOR)
		VALUES (source.PRODUTO, source.VALOR)
		OUTPUT deleted.*, $action, inserted.*;
GO



TRUNCATE TABLE PRODUTOS_NOVOS;
GO

/*  --LISTAR UM PRODUTO QUE NÃO ESTEJA EM NENHUMA VENDA
(UTILIZAR O PRIMEIRO RESULTADO NO 2o INSERT ABAIXO)
SELECT * FROM PRODUTOS P
WHERE NOT EXISTS(
	SELECT *
	FROM ITENS_VENDAS IV
	WHERE P.IDPRODUTO = IV.IDPRODUTO
);
*/

INSERT INTO PRODUTOS_NOVOS
(PRODUTO_NOVO,VALOR_NOVO)
VALUES
('NOVO_PRODUTO02',1),  --PRODUTO NÃO EXISTE
('PRODUTO????????',0),  --PRODUTO EXISTE (NÃO ESTÁ EM NENHUMA VENDA, COMO VERIFICADO LOGO ACIMA)
('PRODUTO1',1);  --PRODUTO EXISTE
GO

SELECT *
FROM PRODUTOS_NOVOS;
GO

--CARREGUE OS PRODUTOS DA TABELA "PRODUTOS_NOVOS" DE ACORDO COM A REGRA ABAIXO
/*
	PRODUTOS DE MESMO NOME, MAS COM VALOR 0, DEVEM SER REMOVIDOS
	PRODUTOS DE MESMO NOME, COM VALOR DIFERENTE DE 0, O VALOR DO PRODUTO DEVE SER ATUALIZADO PARA O NOVO VALOR FORNECIDO
	PRODUTOS QUE NÃO TENHAM CORRESPONDENTE, DEVEM SER INSERIDOS
*/
MERGE PRODUTOS AS target
    USING (SELECT PRODUTO_NOVO, VALOR_NOVO FROM PRODUTOS_NOVOS) AS source (PRODUTO, VALOR)
    ON (target.PRODUTO = source.PRODUTO)
    WHEN MATCHED AND SOURCE.VALOR = 0 THEN
        DELETE
    WHEN MATCHED THEN
		UPDATE SET VALOR = source.VALOR
	WHEN NOT MATCHED THEN
		INSERT (PRODUTO, VALOR)
		VALUES (source.PRODUTO, source.VALOR)
	OUTPUT deleted.*, $action, inserted.*;  --$ACTION SÓ FUNCIONA NO "MERGE"
GO


DECLARE @PRODUTOS TABLE(
	IDPRODUTO INT,
	PRODUTO VARCHAR(100),
	VALOR NUMERIC(6,2)
);

UPDATE PRODUTOS
SET VALOR = 3
OUTPUT DELETED.* INTO @PRODUTOS  --INSERIR EM UMA VARIÁVEL DO TIPO TABLE
WHERE PRODUTO LIKE 'NOVO%';

SELECT *
FROM @PRODUTOS;
GO

--CRIAR TABELA DE AUDITORIA
SELECT NULL AS INT /*PARA QUE NÃO SEJA GERADO COMO IDENTITY*/, PRODUTO, VALOR
INTO AUDITORIA
FROM PRODUTOS
WHERE 1=2;
GO

SELECT *
FROM AUDITORIA;
GO

DELETE FROM PRODUTOS
OUTPUT DELETED.* INTO AUDITORIA  --INSERIR EM UMA TABELA DE AUDITORIA
WHERE PRODUTO LIKE 'NOVO%';
GO

SELECT *
FROM AUDITORIA;
GO

INSERT INTO PRODUTOS
OUTPUT INSERTED.IDPRODUTO  --OBTER O VALOR GERADO POR UM IDENTITY
VALUES
('TESTE_OUTPUT',1);
GO