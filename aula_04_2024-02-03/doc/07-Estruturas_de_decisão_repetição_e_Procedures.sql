USE DISCIPLINA02
GO

--ESTRUTURA DE DECISÃO
DECLARE @BIT BIT
SET @BIT = -1;
select @bit

IF @BIT = 1
	PRINT 'POSITIVO'
ELSE
	PRINT 'NEGATIVO';
GO


--ESTRUTURAS DE REPETIÇÃO
DECLARE @CONTADOR TINYINT, @FIM TINYINT
SELECT @CONTADOR = 1, @FIM = 5;
WHILE @CONTADOR <= @FIM
BEGIN
	PRINT @CONTADOR;

	SET @CONTADOR+=1;
END;
GO

--CRIE UMA PROCEDURE QUE LISTE O NOME E O VALOR DOS 10 PRODUTOS MAIS CAROS
CREATE PROCEDURE USP_LISTA_10_MAIS_CAROS
AS
BEGIN
	SET NOCOUNT ON;  --EVITA O RETORNO DE "(N row(s) affected)"

	SELECT TOP 10 PRODUTO, VALOR
	FROM PRODUTOS
	ORDER BY VALOR DESC;
END;
GO

EXEC USP_LISTA_10_MAIS_CAROS;
GO


--CRIE UMA PROCEDURE QUE AUMENTE EM 5% O VALOR DE TODOS OS PRODUTOS
drop PROCEDURE USP_AUMENTA_EM_5_PORCENTO_VAL_PRODUTOS
AS
BEGIN
	SET NOCOUNT ON;

	UPDATE PRODUTOS
	SET VALOR = VALOR * 1.05;
END;
GO

EXEC USP_AUMENTA_EM_5_PORCENTO_VAL_PRODUTOS;
GO

--CRIE UMA PROCEDURE QUE LISTE OS 10 PRODUTOS MAIS VENDIDOS E A RESPECTIVA QUANTIDADE DE VENDAS DE CADA UM
CREATE PROCEDURE USP_LISTA_10_PRODUTOS_MAIS_VENDIDOS
AS
BEGIN

	SET NOCOUNT ON;

	SELECT TOP 10 P.IDPRODUTO, COUNT(*) AS QTDE
	FROM PRODUTOS P
	INNER JOIN ITENS_VENDAS IV ON (P.IDPRODUTO = IV.IDPRODUTO)
	GROUP BY P.IDPRODUTO
	ORDER BY COUNT(*) DESC;

END;
GO

EXEC USP_LISTA_10_PRODUTOS_MAIS_VENDIDOS;
GO


--CRIE UMA PROCEDURE QUE RECEBA UM PARÂMETRO INTEIRO N E QUE LISTE OS N PRODUTOS MAIS CAROS
CREATE PROCEDURE USP_N_PRODUTOS_MAIS_CAROS(@N SMALLINT)
AS
BEGIN

	SET NOCOUNT ON;

	SELECT TOP(@N) PRODUTO, VALOR
	FROM PRODUTOS
	ORDER BY VALOR DESC;
END;
GO

EXEC USP_N_PRODUTOS_MAIS_CAROS 10;
GO

EXEC USP_N_PRODUTOS_MAIS_CAROS @N = 5;
GO

--CRIE UMA PROCEDURE QUE RECEBA O ID DE UM PRODUTO E UMA PORCENTAGEM INTEIRA PARA ATUALIZAR O VALOR DESSE PRODUTO
CREATE PROCEDURE USP_ATUALIZA_VALOR_PRODUTO(@ID INT, @PERCENT TINYINT)
AS
BEGIN
	SET NOCOUNT ON;

	UPDATE PRODUTOS
	SET VALOR = VALOR + ((VALOR * @PERCENT)/100)
	WHERE IDPRODUTO = @ID;
END;
GO

SELECT *
FROM PRODUTOS
WHERE IDPRODUTO = 10;
GO

EXEC USP_ATUALIZA_VALOR_PRODUTO @ID = 10, @PERCENT = 1;
GO

SELECT *
FROM PRODUTOS
WHERE IDPRODUTO = 10;
GO

EXEC USP_ATUALIZA_VALOR_PRODUTO 10, 1;
GO

SELECT *
FROM PRODUTOS
WHERE IDPRODUTO = 10;
GO

--CRIE UMA PROCEDURE COM O CÓDIGO CRIPTOGRAFADO
CREATE PROCEDURE UPS_CRIPTOGRAFADA
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON;

	SELECT 1;
END;
GO

EXEC UPS_CRIPTOGRAFADA;
GO

EXEC sp_helptext 'dbo.UPS_CRIPTOGRAFADA';
GO




------EXEMPLOS "EXTRAS"

--CRIE UMA PROCEDURE QUE RECEBA UM VALOR LIMITE E QUE LISTE TODOS OS PRODUTOS (NOME E VALOR) ABAIXO DESSE LIMITE DE VALOR
CREATE PROCEDURE dbo.USP_PRODUTO_ABAIXO_DE_VALOR
      @Limite Numeric(6,2) 
    , @Valor Numeric(6,2) OUTPUT
    , @Produto VARCHAR(100) OUT
AS
BEGIN
    SET NOCOUNT ON;

	SELECT @VALOR = VALOR, @PRODUTO = PRODUTO  --COMO ESTOU JOGANDO O RESULTADO DENTRO DE VARIÁVEIS, APENAS O -PRIMEIRO- REGISTRO SERÁ OBTIDO
	FROM PRODUTOS
	WHERE VALOR < @Limite
	ORDER BY VALOR DESC;

END;
GO

DECLARE @VALOR NUMERIC(6,2), @PRODUTO VARCHAR(100);
EXEC USP_PRODUTO_ABAIXO_DE_VALOR 10, @VALOR OUTPUT, @PRODUTO OUTPUT;
SELECT @VALOR, @PRODUTO;


--CRIE UMA PROCEDURE QUE AUMENTE EM 5% O VALOR DE TODOS OS PRODUTOS, COM TRATAMENTO DE ERROS
CREATE PROCEDURE USP_AUMENTA_EM_5_PORCENTO_VAL_PRODUTOS_COM_TRATAMENTO_ERROS
AS
BEGIN
	SET NOCOUNT ON;

	BEGIN TRY
		UPDATE PRODUTOS
		SET VALOR = VALOR * 1.05;
	END TRY
	BEGIN CATCH

	  IF @@TRANCOUNT > 0
		 ROLLBACK

		DECLARE @ErrorMessage nvarchar(4000),  @ErrorSeverity int;
		SELECT @ErrorMessage = 'O erro foi: ' + ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY();
		RAISERROR(@ErrorMessage, @ErrorSeverity, 1);

	END CATCH;
END;
GO

EXEC USP_AUMENTA_EM_5_PORCENTO_VAL_PRODUTOS_COM_TRATAMENTO_ERROS;
GO



CREATE PROCEDURE dbo.USP_PRODUTO_ABAIXO_DE_VALOR_COM_TRATAMENTO_DE_ERROS
      @Limite Numeric(6,2) 
    , @Valor Numeric(6,2) OUTPUT
    , @Produto VARCHAR(100) OUT
AS
BEGIN
    SET NOCOUNT ON;

	IF @Limite < 0  --SE A VARIÁVEL @LIMITE TIVER VALOR MENOR QUE 0
		THROW 51000, 'VALOR ABAIXO DE 0!',1;  --VAI GERAR UMA MENSAGEM DE ERRO, SIMILAR AO QUE FAZ O RAISERROR

	BEGIN TRY

		SELECT @VALOR = VALOR, @PRODUTO = PRODUTO  --COMO ESTOU JOGANDO O RESULTADO DENTRO DE VARIÁVEIS, APENAS O -PRIMEIRO- REGISTRO SERÁ OBTIDO
		FROM PRODUTOS
		WHERE VALOR < @Limite
		ORDER BY VALOR DESC;
	END TRY
	BEGIN CATCH
		IF @@TRANCOUNT > 0
			ROLLBACK;
	END CATCH
END;
GO

DECLARE @VALOR NUMERIC(6,2), @PRODUTO VARCHAR(100);
EXEC USP_PRODUTO_ABAIXO_DE_VALOR_COM_TRATAMENTO_DE_ERROS -1, @VALOR OUTPUT, @PRODUTO OUTPUT;
GO