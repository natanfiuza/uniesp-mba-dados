USE DISCIPLINA02
GO

--CRIE A TABELA ESTOQUES

CREATE TABLE ESTOQUES(
	IDPRODUTO INT NOT NULL,
	QUANTIDADE TINYINT NOT NULL,

	CONSTRAINT PK_ESTOQUES PRIMARY KEY(IDPRODUTO),

	CONSTRAINT FK_ESTOQUES_PRODUTOS FOREIGN KEY(IDPRODUTO) REFERENCES PRODUTOS(IDPRODUTO)
);
GO

--INSIRA O REGISTRO

INSERT INTO ESTOQUES
(IDPRODUTO,QUANTIDADE)
VALUES
(1,10);
GO


--CRIE UMA TRIGGER QUE AO INSERIR UM ITEM DE VENDA, ATUALIZE O ESTOQUE DO PRODUTO
CREATE TRIGGER TRG_ITENS_VENDAS_INSERT
ON ITENS_VENDAS
AFTER INSERT
AS
BEGIN
	SET NOCOUNT ON;

	UPDATE ESTOQUES
	SET QUANTIDADE = E.QUANTIDADE - I.QUANTIDADE
	FROM ESTOQUES E
	INNER JOIN INSERTED I ON (I.IDPRODUTO = E.IDPRODUTO)
END;


--INSIRA UM NOVO ITEM (11) PARA O PRODUTO 1 NA VENDA 1. A QUANTIDADE DEVE SER 2 E O VALOR 100

INSERT INTO ITENS_VENDAS
(IDVENDA,NUMERO_ITEM,IDPRODUTO,VALOR,QUANTIDADE)
VALUES
(1,11,1,100,2);
GO

--VERIFIQUE SE O ESTOQUE FOI ATUALIZADO
SELECT * FROM ESTOQUES;



--ALTER TRIGGER / DROP TRIGGER

--COMENTAR SOBRE TRIGGERS USADAS PARA "SIMULAR" FKs E PARA EXECUTAR REGRAS DE NEGÓCIO
--COMENTAR SOBRE A REAL NECESSIDADE DE TRIGGER HOJE EM DIA






---EXEMPLOS "EXTRAS"


--CRIE UMA TRIGGER QUE IMPEÇA QUE SEJA INSERIDA UMA NOVA UF CASO JÁ EXISTAM 27 NA TABELA UFS
CREATE TRIGGER TRG_UFS_INSERT
ON UFS
AFTER INSERT
AS
BEGIN
	SET NOCOUNT ON;

	IF (
		SELECT COUNT(*)
		FROM UFS
	) > 27
	BEGIN
		RAISERROR ('Já existem 27 UFs cadastradas no sistema!', 16, 1);
		ROLLBACK TRANSACTION;
		RETURN
	END
END;
GO

SELECT COUNT(*)
FROM UFS;
GO

--INSIRA UMA NOVA UF
INSERT INTO UFS
(UF)
VALUES
('XY');
GO

SELECT COUNT(*)
FROM UFS;
GO





--CRIE UMA TRIGGER QUE IMPEÇA QUE SEJAM INSERIDOS OU ALTERADOS ITENS DE VENDA COM VALOR PARA O CAMPO QUANTIDADE MAIOR QUE 100
CREATE TRIGGER TRG_ITENS_VENDAS_INS_UPD
ON ITENS_VENDAS
AFTER INSERT, UPDATE
AS
BEGIN
	SET NOCOUNT ON;

	IF EXISTS(
		SELECT I.QUANTIDADE
		FROM INSERTED AS I
		WHERE QUANTIDADE > 100
	)
	BEGIN
		RAISERROR ('A quantidade de itens em uma venda não pode ser maior que 100!', 16, 1);
		ROLLBACK TRANSACTION;
		RETURN
	END
END;
GO

SELECT *
FROM ITENS_VENDAS
WHERE IDVENDA = 1;
GO

--INSERA UM ITEM DE VENDA COM QUANTIDADE = 101
INSERT INTO ITENS_VENDAS
(IDVENDA,NUMERO_ITEM,IDPRODUTO,VALOR, QUANTIDADE)
VALUES
(1,11,310,100,101);
GO

SELECT *
FROM ITENS_VENDAS
WHERE IDVENDA = 1;
GO

--ATUALIZE UM ITEM DE VENDA, ALTERANDO A QUANTIDADE PARA 101
UPDATE ITENS_VENDAS
SET QUANTIDADE = 101
WHERE IDVENDA = 1 AND NUMERO_ITEM = 1;
GO

SELECT *
FROM ITENS_VENDAS
WHERE IDVENDA = 1;
GO


--CRIE UMA TRIGGER PARA A TABELA PRODUTOS QUE EM CASO DE INSERÇÃO DE PRODUTO ADICIONE O SUFIXO " - INSERIDO MANUALMENTE" AO NOME DO PRODUTO
CREATE TRIGGER TRG_PRODUTOS_INS
ON PRODUTOS
INSTEAD OF INSERT
AS
BEGIN
	SET NOCOUNT ON;

	INSERT INTO PRODUTOS
	(PRODUTO,VALOR)
	SELECT I.PRODUTO + ' - INSERIDO MANUALMENTE', I.VALOR
	FROM INSERTED AS I
END;
GO

--INSIRA UM PRODUTO COM VALOR = 100
INSERT INTO PRODUTOS
(PRODUTO,VALOR)
SELECT 'TESTE',100;
GO

SELECT *
FROM PRODUTOS
WHERE PRODUTO LIKE 'TESTE%';
GO

--ALTERE A TRIGGER CRIADA NO ITEM ANTERIOR DE FORMA QUE A MENSAGEM DE ERRO AGORA TENHA UMA "!" AO FINAL
ALTER TRIGGER TRG_PRODUTOS_INS
ON PRODUTOS
INSTEAD OF INSERT
AS
BEGIN
	SET NOCOUNT ON;

	INSERT INTO PRODUTOS
	(PRODUTO,VALOR)
	SELECT I.PRODUTO + ' - INSERIDO MANUALMENTE!!!', I.VALOR
	FROM INSERTED AS I
END;
GO

--REMOVA A TRIGGER TRG_PRODUTOS_INS
DROP TRIGGER TRG_PRODUTOS_INS;
GO

SELECT TOP 10 * FROM PRODUTOS;

--CRIE UMA TRIGGER QUE, CASO HAJA REMOÇÃO DE PRODUTO COM VALOR MAIOR QUE 100, EXIBA UMA MENSAGEM DE ERRO E DESFAÇA A ALTERAÇÃO
CREATE TRIGGER TRG_PRODUTOS_DEL
ON PRODUTOS
AFTER DELETE
AS
BEGIN
	SET NOCOUNT ON;

	IF EXISTS(
		SELECT 1
		FROM DELETED AS D
		WHERE D.VALOR > 1000
	)
	BEGIN
		RAISERROR ('Não é possível remover produtos com valor maior que 1000!', 16, 1);
		ROLLBACK TRANSACTION;
		RETURN
	END
END;
GO

SELECT *
FROM PRODUTOS
WHERE VALOR > 900
ORDER BY VALOR ASC;
GO

--REMOVA OS PRODUTOS COM VALOR MAIOR QUE 900
DELETE FROM PRODUTOS
WHERE VALOR > 900;
GO




--CRIAR ROTINA DE AUDITORIA DE DDL UTILIZANDO TRIGGERS DE DATABASE
CREATE TABLE [dbo].[Auditoria](
	[IdLog] [int] IDENTITY(1,1) NOT NULL,
	[Banco] [varchar](256) NOT NULL,
	[TipoEvento] [varchar](50) NOT NULL,
	[NomeObjeto] [varchar](256) NOT NULL,
	[TipoObjeto] [varchar](25) NOT NULL,
	[Sql] [varchar](max) NOT NULL,
	[DataEvento] [datetime] NOT NULL CONSTRAINT [DF_EventsLog_EventDate]  DEFAULT (getdate()),
	[Login] [varchar](256) NOT NULL
 CONSTRAINT [PK_LogAlteracaoEsquema] PRIMARY KEY CLUSTERED 
([IdLog] ASC));
GO

CREATE TRIGGER [Trg_Auditoria]
ON DATABASE
FOR CREATE_PROCEDURE,
    ALTER_PROCEDURE,
    DROP_PROCEDURE,
    CREATE_TABLE,
    ALTER_TABLE,
    DROP_TABLE,
    CREATE_FUNCTION,
    ALTER_FUNCTION,
    DROP_FUNCTION,
    CREATE_TRIGGER,
    ALTER_TRIGGER,
    DROP_TRIGGER,
	CREATE_VIEW,
	ALTER_VIEW,
	DROP_VIEW
AS

SET NOCOUNT ON

DECLARE @data XML
SET @data = EVENTDATA()

BEGIN
	INSERT INTO Auditoria(Banco, TipoEvento, NomeObjeto, TipoObjeto, SQL, Login)
	VALUES(
	@data.value('(/EVENT_INSTANCE/DatabaseName)[1]', 'varchar(256)'),
	@data.value('(/EVENT_INSTANCE/EventType)[1]', 'varchar(50)'), 
	@data.value('(/EVENT_INSTANCE/ObjectName)[1]', 'varchar(256)'), 
	@data.value('(/EVENT_INSTANCE/ObjectType)[1]', 'varchar(25)'), 
	@data.value('(/EVENT_INSTANCE/TSQLCommand)[1]', 'varchar(max)'), 
	@data.value('(/EVENT_INSTANCE/LoginName)[1]', 'varchar(256)')
	)
END
GO

ENABLE TRIGGER [Trg_Auditoria] ON DATABASE
GO

SELECT *
FROM AUDITORIA;
GO

CREATE PROCEDURE USP_TESTE_AUDITORIA
AS
BEGIN
	SELECT 1;
END;
GO

ALTER PROCEDURE USP_TESTE_AUDITORIA
AS
BEGIN
	SELECT 2;
END;
GO

DROP PROCEDURE USP_TESTE_AUDITORIA;
GO

SELECT *
FROM AUDITORIA;
GO

DROP TABLE AUDITORIA;
GO

DROP TRIGGER [Trg_Auditoria] ON DATABASE;
GO

DROP TABLE AUDITORIA;
GO




--CRIE UMA TRIGGER DE AUDITORIA DDL A NÍVEL DE SERVIDOR
CREATE TABLE [dbo].[Auditoria](
	[IdLog] [int] IDENTITY(1,1) NOT NULL,
	[Banco] [varchar](256) NOT NULL,
	[TipoEvento] [varchar](50) NOT NULL,
	[NomeObjeto] [varchar](256) NOT NULL,
	[TipoObjeto] [varchar](25) NOT NULL,
	[Sql] [varchar](max) NOT NULL,
	[DataEvento] [datetime] NOT NULL CONSTRAINT [DF_EventsLog_EventDate]  DEFAULT (getdate()),
	[Login] [varchar](256) NOT NULL
 CONSTRAINT [PK_LogAlteracaoEsquema] PRIMARY KEY CLUSTERED 
([IdLog] ASC));
GO


CREATE TRIGGER [Trg_Auditoria_Servidor]
ON ALL SERVER
FOR CREATE_PROCEDURE,
    ALTER_PROCEDURE,
    DROP_PROCEDURE,
    CREATE_TABLE,
    ALTER_TABLE,
    DROP_TABLE,
    CREATE_FUNCTION,
    ALTER_FUNCTION,
    DROP_FUNCTION,
    CREATE_TRIGGER,
    ALTER_TRIGGER,
    DROP_TRIGGER,
	CREATE_VIEW,
	ALTER_VIEW,
	DROP_VIEW
AS

SET NOCOUNT ON

DECLARE @data XML
SET @data = EVENTDATA()

BEGIN
	INSERT INTO DISCIPLINA02.dbo.Auditoria(Banco, TipoEvento, NomeObjeto, TipoObjeto, SQL, Login)
	VALUES(
	@data.value('(/EVENT_INSTANCE/DatabaseName)[1]', 'varchar(256)'),
	@data.value('(/EVENT_INSTANCE/EventType)[1]', 'varchar(50)'), 
	@data.value('(/EVENT_INSTANCE/ObjectName)[1]', 'varchar(256)'), 
	@data.value('(/EVENT_INSTANCE/ObjectType)[1]', 'varchar(25)'), 
	@data.value('(/EVENT_INSTANCE/TSQLCommand)[1]', 'varchar(max)'), 
	@data.value('(/EVENT_INSTANCE/LoginName)[1]', 'varchar(256)')
	)
END;
GO

USE MASTER;
GO
CREATE PROCEDURE USP_TESTE_AUDITORIA2
AS
BEGIN
	SELECT 1;
END;
GO

SELECT *
FROM DISCIPLINA02.DBO.Auditoria;
GO


--CRIE UMA TRIGGER DE LOGON QUE PROIBA O ACESSO DO USUÁRIO "TESTE"

USE [master]
GO
CREATE LOGIN [teste] WITH PASSWORD=N'teste', DEFAULT_DATABASE=[master];
GO


CREATE TRIGGER [Trg_Proibe_Acesso_teste]
ON ALL SERVER
FOR LOGON
AS
BEGIN

	IF (SUSER_SNAME() = 'teste') AND (app_name() NOT IN('minhaApp'))
		ROLLBACK;
END;
GO


--PRECISO DE TRIGGERS PARA FAZER AUDITORIA?!
--UTILIZANDO O OUTPUT PARA AUDITORIAS

CREATE TABLE AUDITORIA_PRODUTOS(
	IDPRODUTO INT NOT NULL,
	PRODUTO VARCHAR(100) NOT NULL,
	VALOR NUMERIC(6,2) NOT NULL,
	USUARIO SYSNAME NOT NULL,
	DATA_HORA DATETIME NOT NULL
);
GO

SELECT *
FROM AUDITORIA_PRODUTOS;
GO

UPDATE PRODUTOS
SET VALOR = 5
OUTPUT DELETED.IDPRODUTO,DELETED.PRODUTO,DELETED.VALOR,SYSTEM_USER, GETDATE() INTO AUDITORIA_PRODUTOS
WHERE IDPRODUTO = 2;
GO

SELECT *
FROM AUDITORIA_PRODUTOS;
GO